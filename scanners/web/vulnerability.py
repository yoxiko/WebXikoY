import aiohttp
from typing import List, Dict, Any
from urllib.parse import urljoin
from .payloads import SQLI_PAYLOADS, XSS_PAYLOADS, COMMAND_INJECTION_PAYLOADS

class WebVulnerabilityScanner:
    def __init__(self, config, session):
        self.config = config
        self.session = session
        self.vulnerabilities = []

    async def scan_target(self, target: str) -> List[Dict[str, Any]]:
        if not target.startswith(('http://', 'https://')):
            target = f'http://{target}'
        
        self.vulnerabilities = []
        
        await self._crawl_and_scan(target)
        
        return self.vulnerabilities

    async def _crawl_and_scan(self, url: str):
        try:
            async with self.session.get(url) as response:
                if response.status == 200:
                    forms = await self._extract_forms(await response.text(), url)
                    
                    for form in forms:
                        await self._test_sql_injection(form, url)
                        await self._test_xss(form, url)
                        await self._test_command_injection(form, url)
                    
                    links = await self._extract_links(await response.text(), url)
                    for link in links[:10]:
                        await self._crawl_and_scan(link)
        except Exception:
            pass

    async def _extract_forms(self, html: str, base_url: str) -> List[Dict]:
        from bs4 import BeautifulSoup
        forms = []
        
        soup = BeautifulSoup(html, 'html.parser')
        for form in soup.find_all('form'):
            form_action = form.get('action', '')
            form_method = form.get('method', 'get').lower()
            form_inputs = []
            
            for input_tag in form.find_all(['input', 'textarea']):
                input_name = input_tag.get('name')
                if input_name:
                    form_inputs.append({
                        'name': input_name,
                        'type': input_tag.get('type', 'text')
                    })
            
            forms.append({
                'action': urljoin(base_url, form_action),
                'method': form_method,
                'inputs': form_inputs
            })
        
        return forms

    async def _extract_links(self, html: str, base_url: str) -> List[str]:
        from bs4 import BeautifulSoup
        links = []
        
        soup = BeautifulSoup(html, 'html.parser')
        for link in soup.find_all('a', href=True):
            href = link['href']
            full_url = urljoin(base_url, href)
            if full_url.startswith(('http://', 'https://')):
                links.append(full_url)
        
        return links

    async def _test_sql_injection(self, form: Dict, url: str):
        for payload in SQLI_PAYLOADS:
            data = {}
            for input_field in form['inputs']:
                data[input_field['name']] = payload
            
            try:
                if form['method'] == 'get':
                    async with self.session.get(form['action'], params=data) as response:
                        if await self._detect_sqli_patterns(await response.text()):
                            self._add_vulnerability('SQL Injection', form['action'], payload)
                else:
                    async with self.session.post(form['action'], data=data) as response:
                        if await self._detect_sqli_patterns(await response.text()):
                            self._add_vulnerability('SQL Injection', form['action'], payload)
            except Exception:
                continue

    async def _test_xss(self, form: Dict, url: str):
        for payload in XSS_PAYLOADS:
            data = {}
            for input_field in form['inputs']:
                data[input_field['name']] = payload
            
            try:
                if form['method'] == 'get':
                    async with self.session.get(form['action'], params=data) as response:
                        if payload in await response.text():
                            self._add_vulnerability('XSS', form['action'], payload)
                else:
                    async with self.session.post(form['action'], data=data) as response:
                        if payload in await response.text():
                            self._add_vulnerability('XSS', form['action'], payload)
            except Exception:
                continue

    async def _test_command_injection(self, form: Dict, url: str):
        for payload in COMMAND_INJECTION_PAYLOADS:
            data = {}
            for input_field in form['inputs']:
                data[input_field['name']] = f"test{payload}"
            
            try:
                if form['method'] == 'get':
                    async with self.session.get(form['action'], params=data) as response:
                        if await self._detect_command_injection_patterns(await response.text()):
                            self._add_vulnerability('Command Injection', form['action'], payload)
                else:
                    async with self.session.post(form['action'], data=data) as response:
                        if await self._detect_command_injection_patterns(await response.text()):
                            self._add_vulnerability('Command Injection', form['action'], payload)
            except Exception:
                continue

    async def _detect_sqli_patterns(self, response_text: str) -> bool:
        error_patterns = [
            "mysql_fetch_array",
            "ORA-",
            "Microsoft OLE DB Provider",
            "PostgreSQL",
            "SQLite",
            "SQL syntax"
        ]
        return any(pattern in response_text for pattern in error_patterns)

    async def _detect_command_injection_patterns(self, response_text: str) -> bool:
        patterns = [
            "root:",
            "bin/bash",
            "etc/passwd",
            "Permission denied"
        ]
        return any(pattern in response_text for pattern in patterns)

    def _add_vulnerability(self, vuln_type: str, location: str, payload: str):
        self.vulnerabilities.append({
            'type': vuln_type,
            'location': location,
            'payload': payload,
            'severity': self._get_severity(vuln_type)
        })

    def _get_severity(self, vuln_type: str) -> str:
        severity_map = {
            'SQL Injection': 'high',
            'XSS': 'medium',
            'Command Injection': 'high'
        }
        return severity_map.get(vuln_type, 'low')